<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一維掃描線演算法 (1D Scanline) 視覺化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .transition-all-500 { transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .segment-bar {
            position: absolute;
            height: 16px;
            border-radius: 8px;
            opacity: 0.8;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .scan-line {
            position: absolute;
            top: 0; bottom: 0;
            width: 2px;
            background-color: #ef4444; /* red-500 */
            z-index: 20;
            transition: left 0.8s ease-in-out;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }
        .covered-region {
            position: absolute;
            bottom: 40px; /* On the number line */
            height: 8px;
            background-color: #22c55e; /* green-500 */
            border-radius: 4px;
            z-index: 10;
            transition: width 0.8s ease-in-out;
        }
        .event-marker {
            position: absolute;
            bottom: 10px;
            transform: translateX(-50%);
            font-size: 12px;
            font-family: monospace;
            color: #64748b;
            transition: color 0.3s;
        }
        .event-marker.active {
            color: #ef4444;
            font-weight: bold;
            font-size: 14px;
        }
        .counter-badge {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #0f172a;
            color: white;
            padding: 4px 12px;
            border-radius: 9999px;
            font-weight: bold;
            font-family: monospace;
            z-index: 30;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-slate-50 min-h-screen font-sans text-slate-800 flex flex-col">

    <!-- Header -->
    <nav class="bg-white border-b border-slate-200 px-6 py-4 shadow-sm">
        <div class="max-w-4xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
            <h1 class="text-xl font-bold text-slate-900 flex items-center gap-2">
                <svg class="text-red-500" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 21h5v-5"/></svg>
                一維掃描線演算法 (1D Scanline)
            </h1>
            <div class="flex items-center gap-2">
                <span class="text-sm text-slate-500 bg-slate-100 px-3 py-1 rounded-full">入門：線段覆蓋總長</span>
            </div>
        </div>
    </nav>

    <!-- Main -->
    <main class="flex-grow p-4 md:p-8 max-w-4xl mx-auto w-full space-y-6">

        <!-- Explanation Card -->
        <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <h2 class="text-lg font-bold text-slate-800 mb-2 border-l-4 border-red-500 pl-3">核心觀念 (最簡化版)</h2>
            <p class="text-slate-600 text-sm leading-relaxed mb-4">
                我們有一條垂直的掃描線從左往右移動。
                我們只需要維護一個變數：<span class="font-bold text-blue-600 bg-blue-50 px-1 rounded">重疊層數 (Active Count)</span>。
                <br><br>
                規則非常簡單：
                <ul class="list-disc list-inside ml-2 mt-1 space-y-1">
                    <li>遇到線段<span class="text-green-600 font-bold">起點</span>：層數 +1</li>
                    <li>遇到線段<span class="text-red-600 font-bold">終點</span>：層數 -1</li>
                    <li>只要 <span class="font-bold text-blue-600">層數 > 0</span>，掃過的距離就計入總長度。</li>
                </ul>
            </p>
            <div class="flex gap-4">
                <button onclick="app.nextStep()" id="btn-next" class="px-6 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-bold shadow-md transition-all flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    下一步
                </button>
                <button onclick="app.reset()" class="px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-lg font-bold transition-all">
                    重置
                </button>
            </div>
        </div>

        <!-- Visualization Area -->
        <div class="grid lg:grid-cols-3 gap-6">
            
            <!-- Canvas -->
            <div class="lg:col-span-2 bg-white rounded-2xl shadow-md border border-slate-200 relative h-[300px] select-none overflow-hidden" id="canvas-container">
                
                <!-- Number Line Axis -->
                <div class="absolute bottom-[44px] left-0 right-0 h-[2px] bg-slate-300"></div>
                <div class="absolute bottom-[20px] left-2 text-xs text-slate-400 font-bold">數線 (X軸)</div>

                <!-- Elements (Injected by JS) -->
                <div id="segments-layer" class="relative w-full h-full"></div>
                
                <!-- Scanline -->
                <div id="scanline" class="scan-line" style="left: 0px;">
                    <div class="counter-badge" id="scanline-counter">層數: 0</div>
                </div>

                <!-- Markers -->
                <div id="markers-layer" class="absolute bottom-0 w-full h-10 pointer-events-none"></div>

                <!-- Result Layer (Green line on axis) -->
                <div id="result-layer"></div>
            </div>

            <!-- Dashboard -->
            <div class="flex flex-col gap-4">
                <!-- Status Panel -->
                <div class="bg-slate-800 p-5 rounded-2xl text-white shadow-lg flex-grow flex flex-col justify-center">
                    <div class="flex justify-between items-center border-b border-slate-600 pb-3 mb-3">
                        <span class="text-xs font-bold text-slate-400 uppercase">當前狀態</span>
                        <span class="text-xs font-mono bg-slate-700 px-2 py-1 rounded text-red-300" id="step-counter">Start</span>
                    </div>

                    <div class="space-y-6">
                        <div>
                            <div class="text-[10px] text-slate-400 uppercase mb-1">重疊層數 (Active Count)</div>
                            <div class="text-4xl font-mono font-bold text-blue-400" id="val-count">0</div>
                            <div class="text-xs text-slate-500 mt-1" id="count-desc">目前沒有線段覆蓋</div>
                        </div>

                        <div class="pt-4 border-t border-slate-600">
                            <div class="text-[10px] text-slate-400 uppercase mb-1">本次移動 (dX)</div>
                            <div class="font-mono text-slate-300 text-sm mb-2" id="calc-dx">0</div>
                            
                            <div class="text-[10px] text-slate-400 uppercase mb-1">增加長度 (+Len)</div>
                            <div class="font-mono text-green-400 font-bold text-xl mb-2" id="calc-len">+ 0</div>
                        </div>
                    </div>

                    <div class="mt-auto pt-4 border-t border-slate-600">
                        <div class="flex justify-between items-end">
                            <span class="text-sm font-bold text-slate-300">總覆蓋長度</span>
                            <span class="text-3xl font-mono font-bold text-white" id="val-total">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </main>

    <script>
        const app = {
            // Data: 1D Intervals
            segments: [
                { id: 1, x1: 50, x2: 250, y: 80, color: 'bg-blue-400' },
                { id: 2, x1: 150, x2: 350, y: 130, color: 'bg-orange-400' },
                { id: 3, x1: 400, x2: 500, y: 100, color: 'bg-purple-400' }
            ],

            // State
            events: [],
            currentStep: -1,
            activeCount: 0,
            totalLength: 0,
            
            init() {
                this.generateEvents();
                this.renderStatic();
                this.updateUIValues(0, 0, 0, 0, 0);

                window.addEventListener('resize', () => {
                    // Simple refresh logic if needed
                });
            },

            generateEvents() {
                // Event: { x, type: 1(start)|-1(end), id }
                this.events = [];
                this.segments.forEach(s => {
                    this.events.push({ x: s.x1, type: 1, id: s.id });
                    this.events.push({ x: s.x2, type: -1, id: s.id });
                });
                // Sort by X
                this.events.sort((a, b) => a.x - b.x);
            },

            renderStatic() {
                const layer = document.getElementById('segments-layer');
                const markers = document.getElementById('markers-layer');
                layer.innerHTML = '';
                markers.innerHTML = '';

                // Draw Segments
                this.segments.forEach(s => {
                    const el = document.createElement('div');
                    el.className = `segment-bar ${s.color}`;
                    el.style.left = s.x1 + 'px';
                    el.style.width = (s.x2 - s.x1) + 'px';
                    el.style.top = s.y + 'px';
                    
                    // Add dashed lines down to axis for clarity
                    const dropLine1 = document.createElement('div');
                    dropLine1.className = 'absolute top-full bottom-[-100px] border-l border-dashed border-slate-300 opacity-50';
                    dropLine1.style.left = s.x1 + 'px';
                    dropLine1.style.top = (s.y + 16) + 'px';
                    dropLine1.style.height = (256 - s.y) + 'px'; // approximate to axis
                    
                    const dropLine2 = dropLine1.cloneNode();
                    dropLine2.style.left = s.x2 + 'px';
                    
                    layer.appendChild(el);
                    layer.appendChild(dropLine1);
                    layer.appendChild(dropLine2);
                });

                // Draw Markers
                this.events.forEach((e, idx) => {
                    const el = document.createElement('div');
                    el.className = `event-marker`;
                    el.style.left = e.x + 'px';
                    el.innerText = e.x;
                    el.id = `marker-${idx}`;
                    markers.appendChild(el);
                });
            },

            nextStep() {
                if (this.currentStep < this.events.length - 1) {
                    this.currentStep++;
                    this.animateToStep(this.currentStep);
                } else {
                    // Reset Logic
                    const btn = document.getElementById('btn-next');
                    btn.innerText = '演示結束 (重置)';
                    btn.onclick = () => this.reset();
                    btn.className = "px-6 py-2 bg-slate-700 hover:bg-slate-800 text-white rounded-lg font-bold shadow-md transition-all flex items-center gap-2";
                }
            },

            reset() {
                this.currentStep = -1;
                this.activeCount = 0;
                this.totalLength = 0;
                
                document.getElementById('result-layer').innerHTML = '';
                document.getElementById('scanline').style.left = '0px';
                document.getElementById('scanline-counter').innerText = '層數: 0';
                document.getElementById('scanline-counter').className = 'counter-badge bg-slate-900';

                this.updateUIValues(0, 0, 0, 0, 0);
                
                const btn = document.getElementById('btn-next');
                btn.innerText = '下一步';
                btn.onclick = () => this.nextStep();
                btn.className = "px-6 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg font-bold shadow-md transition-all flex items-center gap-2";
                
                document.querySelectorAll('.event-marker').forEach(el => el.classList.remove('active'));
            },

            animateToStep(stepIndex) {
                const event = this.events[stepIndex];
                const prevEvent = stepIndex > 0 ? this.events[stepIndex - 1] : { x: 0 };
                
                // 1. Move Scanline
                const line = document.getElementById('scanline');
                line.style.left = event.x + 'px';

                // Highlight Marker
                document.querySelectorAll('.event-marker').forEach(el => el.classList.remove('active'));
                document.getElementById(`marker-${stepIndex}`).classList.add('active');

                // 2. Calculate Coverage (Logic: if activeCount > 0, we add length)
                const dx = event.x - prevEvent.x;
                const addedLength = this.activeCount > 0 ? dx : 0;
                
                // Visualise Coverage on Axis
                if (addedLength > 0) {
                    const bar = document.createElement('div');
                    bar.className = 'covered-region';
                    bar.style.left = prevEvent.x + 'px';
                    bar.style.width = dx + 'px';
                    document.getElementById('result-layer').appendChild(bar);
                }

                this.totalLength += addedLength;

                // 3. Update UI BEFORE changing count (showing what happened during the move)
                setTimeout(() => {
                    this.updateUIValues(event.x, this.activeCount, dx, addedLength, this.totalLength);
                    
                    // 4. Update Count for NEXT segment
                    if (event.type === 1) {
                        this.activeCount++; 
                    } else {
                        this.activeCount--;
                    }
                    
                    // Update Badge on Line
                    const badge = document.getElementById('scanline-counter');
                    badge.innerText = `層數: ${this.activeCount}`;
                    if (this.activeCount > 0) {
                        badge.style.background = '#22c55e'; // Green when active
                    } else {
                        badge.style.background = '#0f172a'; // Dark when inactive
                    }

                }, 800); // Sync with animation
            },

            updateUIValues(x, count, dx, add, total) {
                document.getElementById('step-counter').innerText = `Step ${this.currentStep + 1} / ${this.events.length}`;
                
                document.getElementById('val-count').innerText = count;
                const desc = document.getElementById('count-desc');
                if (count === 0) {
                    desc.innerText = "目前沒有線段覆蓋 (空白區)";
                    desc.className = "text-xs text-slate-500 mt-1";
                } else {
                    desc.innerText = `目前有 ${count} 條線段重疊 (有效覆蓋)`;
                    desc.className = "text-xs text-green-400 mt-1 font-bold";
                }

                document.getElementById('calc-dx').innerText = `${x} - ${x-dx} = ${dx}`;
                document.getElementById('calc-len').innerText = `+ ${add}`;
                document.getElementById('val-total').innerText = total;
            }
        };

        app.init();
    </script>
</body>
</html>